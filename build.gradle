import groovy.json.JsonSlurper
import groovy.json.JsonBuilder

buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven { url = 'http://files.minecraftforge.net/maven' }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
    }
}

plugins {
    id 'groovy'
}

apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'java'

def config = null

file "${projectDir.getAbsolutePath()}/config.json" withReader {
    config = new JsonSlurper().parseText(it.text)
}

version = "${config.version.major}.${config.version.minor}.${config.version.patch}"
group = 'dev.satyrn.wolfarmor.api'
archivesBaseName = 'wolfarmorapi'

sourceCompatibility = targetCompatibility = '1.8'
compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
    doFirst {
        copy {
            from sourceSets.main.allJava
            into "$buildDir/generated/main/java"
            expand version: version, mcversion: config.minecraft.version, modname: config.name, modid: config.modid
        }
        copy {
            from "$buildDir/generated/main/java"
            into "$buildDir/sources/main/java"
        }
    }
}

sourceSets.main {
    java {
        srcDirs 'src/main/java'
    }
}

sourceSets.test {
    dependencies {
        testCompile 'org.codehaus.groovy:groovy-all:2.5.7'
        testCompile 'org.spockframework:spock-core:1.3-groovy-2.5'
        testCompile 'junit:junit:4.12'
        testRuntime 'org.objenesis:objenesis:2.6'
        testRuntime 'net.bytebuddy:byte-buddy:1.9.3'
    }
    java {
        srcDirs 'src/test/groovy'
    }
}

runClient.enabled = false
runServer.enabled = false

processResources {
    // copy LICENSE
    from('/') {
        include 'LICENSE'
        include 'THIRDPARTY'
    }
}

minecraft {
    version = "${config.minecraft.version}-${config.forge.version}"
    runDir = "run"
    mappings = config.mcp.version
}

jar {
    manifest {
        attributes([
            "Specification-Title": "Wolf Armor API",
            "Specification-Vendor": "Isabel Maskrey",
            "Specification-Version": project.version,
            "Implementation-Title": project.name,
            "Implementation-Version": "${version}",
            "Implementation-Vendor" :"Isabel Maskrey",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

task saveConfig {
    doLast {
        def configFile = new File("${projectDir.getAbsolutePath()}/config.json")
        configFile.delete()
        configFile.write(new JsonBuilder(config).toPrettyString())
    }
}

def VERSIONING_GROUP = 'Versioning'
def SCM_GROUP = 'sourcecontrol'

task incrementApiPatch {
    group VERSIONING_GROUP
    dependsOn 'gitCheckWorkingTree'
    finalizedBy 'saveConfig'
    finalizedBy 'gitAddConfig'
    finalizedBy 'gitTagVersion'
    finalizedBy 'gitCommit'
    finalizedBy 'reportVersionChange'

    doLast {
        println projectDir.getAbsolutePath()
        if (gitCheckWorkingTree.output() != "") {
            saveConfig.enabled = false
            gitAddConfig.enabled = false
            gitTagVersion.enabled = false
            gitCommit.enabled = false
            throw new Error("Working directory not clean!")
        } else {
            config.version.patch += 1
        }
    }
}

task incrementApiMinor {
    group VERSIONING_GROUP
    dependsOn 'gitCheckWorkingTree'
    finalizedBy 'saveConfig'
    finalizedBy 'gitAddConfig'
    finalizedBy 'gitTagVersion'
    finalizedBy 'gitCommit'
    finalizedBy 'reportVersionChange'

    doLast {
        println projectDir.getAbsolutePath()
        if (gitCheckWorkingTree.output() != "") {
            saveConfig.enabled = false
            gitAddConfig.enabled = false
            gitTagVersion.enabled = false
            gitCommit.enabled = false
            throw new Error("Working directory not clean!")
        } else {
            config.version.patch = 0
            config.version.minor += 1
        }
    }
}

task incrementApiMajor {
    group VERSIONING_GROUP
    dependsOn 'gitCheckWorkingTree'
    finalizedBy 'saveConfig'
    finalizedBy 'gitAddConfig'
    finalizedBy 'gitTagVersion'
    finalizedBy 'gitCommit'
    finalizedBy 'reportVersionChange'

    doLast {
        println projectDir.getAbsolutePath()
        if (gitCheckWorkingTree.output() != "") {
            saveConfig.enabled = false
            gitAddConfig.enabled = false
            gitTagVersion.enabled = false
            gitCommit.enabled = false
            throw new Error("Working directory not clean!")
        } else {
            config.version.patch = 0
            config.version.minor = 0
            config.version.major += 1
        }
    }
}

task gitCheckWorkingTree(type:Exec) {
    group SCM_GROUP
    workingDir projectDir.getAbsolutePath()
    executable 'git'
    args '--no-pager', 'diff', 'HEAD'
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString()
    }
}

task gitAddConfig(type:Exec) {
    group SCM_GROUP
    shouldRunAfter saveConfig
    workingDir projectDir.getAbsolutePath()
    ignoreExitValue true
    executable 'git'
    args 'add', 'config.json'
}

task gitTagVersion(type:Exec) {
    group SCM_GROUP
    shouldRunAfter gitAddConfig
    workingDir projectDir.getAbsolutePath()
    def newVersionNum = "v${config.version.major}.${config.version.minor}.${config.version.patch}"
    ignoreExitValue true
    executable 'git'
    args 'tag', '-a', "${newVersionNum}", '-m', "\"${newVersionNum}\""
}

task gitCommit(type:Exec) {
    group SCM_GROUP
    shouldRunAfter gitTagVersion
    workingDir projectDir.getAbsolutePath()
    def newVersionNum = "v${config.version.major}.${config.version.minor}.${config.version.patch}"
    ignoreExitValue true
    executable 'git'
    args 'commit', '-m', "\"üè∑ ${newVersionNum}\""
}

task reportVersionChange {
    group VERSIONING_GROUP
    shouldRunAfter gitCommit
    doLast {
        println "Current semver: ${config.version.major}.${config.version.minor}.${config.version.patch}"
    }
}
